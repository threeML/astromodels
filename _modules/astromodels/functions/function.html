

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>astromodels.functions.function &mdash; Astromodels latest documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <link rel="stylesheet" href="../../../_static/pygments/default.css" type="text/css" id="pygments-style">
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css">
   

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> Astromodels
          

          
            
            <img src="../../../_static/transp_logo.png" class="logo" alt="Logo"/>
          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Quick_start.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../function_docs/functions.html">Builtin Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../function_docs/functions.html#contents">Contents:</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Functions_tutorial.html">Functions tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Point_source_tutorial.html">Point sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Extended_sources_tutorial.html">Extended source tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Multi_component_sources.html">Multi-component sources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Model_tutorial.html">Model tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Priors_for_Bayesian_analysis.html">Priors for Bayesian analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/Additional_features_for_scripts_and_applications.html">Additional features for scripts and applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/API.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/API.html#astromodels">astromodels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release_notes.html">Release Notes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Astromodels</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
  <!--
  <div class="admonition note">
    <p><a href="https://github.com/lukelbd">ProPlot author here</a>: Due to my day job as a graduate student, certain <a href="https://github.com/lukelbd/proplot/pulls?q=is%3Aopen+is%3Apr">feature additions</a> may be delayed to the summer of 2020. In the meantime, if you are interested in contributing to ProPlot, please see the <a href="https://proplot.readthedocs.io/en/latest/contributions.html">contribution guide</a>. Any amount of help is welcome!
    </p>
  </div>
  -->
  <li id="lightdark-li">
    <label for="lightdark-checkbox" id="lightdark-label">
      <input type="checkbox" id="lightdark-checkbox"/>
      <div class="btn-neutral"></div>
    </label>
  </li>
  
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>astromodels.functions.function</li>
    

    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
  <script type="text/javascript" src=../../../_static/custom.js></script>
  
           <div itemprop="articleBody">
            
  <h1>Source code for astromodels.functions.function</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">ast</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">chr</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">str</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">astropy.units</span> <span class="k">as</span> <span class="nn">u</span>
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="nn">nb</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">yaml.reader</span> <span class="kn">import</span> <span class="n">ReaderError</span>

<span class="kn">from</span> <span class="nn">astromodels.core.memoization</span> <span class="kn">import</span> <span class="n">memoize</span>
<span class="kn">from</span> <span class="nn">astromodels.core.my_yaml</span> <span class="kn">import</span> <span class="n">my_yaml</span>
<span class="kn">from</span> <span class="nn">astromodels.core.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">astromodels.core.parameter_transformation</span> <span class="kn">import</span> <span class="n">get_transformation</span>
<span class="kn">from</span> <span class="nn">astromodels.core.tree</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">astromodels.utils.pretty_list</span> <span class="kn">import</span> <span class="n">dict_to_list</span>
<span class="kn">from</span> <span class="nn">astromodels.utils.table</span> <span class="kn">import</span> <span class="n">dict_to_table</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;giacomov&#39;</span>


<span class="k">try</span><span class="p">:</span>

    <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">HTML</span><span class="p">,</span> <span class="n">display</span>

<span class="k">except</span><span class="p">:</span>

    <span class="n">has_ipython</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">else</span><span class="p">:</span>

    <span class="n">has_ipython</span> <span class="o">=</span> <span class="kc">True</span>


<div class="viewcode-block" id="WarningNoTests"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.WarningNoTests">[docs]</a><span class="k">class</span> <span class="nc">WarningNoTests</span><span class="p">(</span><span class="ne">ImportWarning</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="FunctionDefinitionError"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.FunctionDefinitionError">[docs]</a><span class="k">class</span> <span class="nc">FunctionDefinitionError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="DesignViolation"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.DesignViolation">[docs]</a><span class="k">class</span> <span class="nc">DesignViolation</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ModelAssertionViolation"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.ModelAssertionViolation">[docs]</a><span class="k">class</span> <span class="nc">ModelAssertionViolation</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="WrongDimensionality"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.WrongDimensionality">[docs]</a><span class="k">class</span> <span class="nc">WrongDimensionality</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="TestSpecificationError"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.TestSpecificationError">[docs]</a><span class="k">class</span> <span class="nc">TestSpecificationError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="TestFailed"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.TestFailed">[docs]</a><span class="k">class</span> <span class="nc">TestFailed</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="DocstringIsNotRaw"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.DocstringIsNotRaw">[docs]</a><span class="k">class</span> <span class="nc">DocstringIsNotRaw</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="UnknownFunction"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.UnknownFunction">[docs]</a><span class="k">class</span> <span class="nc">UnknownFunction</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="UnknownParameter"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.UnknownParameter">[docs]</a><span class="k">class</span> <span class="nc">UnknownParameter</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span></div>


<span class="c1"># Value to indicate that no latex formula has been given</span>
<span class="n">NO_LATEX_FORMULA</span> <span class="o">=</span> <span class="s1">&#39;(no latex formula available)&#39;</span>


<span class="c1"># A function to find the calling sequence of a function, compatible</span>
<span class="c1"># with both python2 and 3</span>
<span class="k">def</span> <span class="nf">_py2to3_getargspec</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>

        <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># PY3</span>

        <span class="n">argspec</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getfullargspec</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">argspec</span>


<span class="c1"># This dictionary will contain the known function by name, so that the model_parser can instance</span>
<span class="c1"># them by looking into this dictionary. It will be filled by the FunctionMeta meta-class.</span>

<span class="n">_known_functions</span> <span class="o">=</span> <span class="p">{}</span>


<span class="c1"># The following is a metaclass for all the functions</span>
<div class="viewcode-block" id="FunctionMeta"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.FunctionMeta">[docs]</a><span class="k">class</span> <span class="nc">FunctionMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A metaclass for the models, which takes care of setting up the parameters and the other attributes</span>
<span class="sd">    according to the definition given in the documentation of the function class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>

        <span class="c1"># We do the parsing of the parameters in the __new__ instead of the __init__ so this is the first thing</span>
        <span class="c1"># that runs when importing astromodels</span>

        <span class="c1"># Enforce the presence of the evaluate method</span>

        <span class="k">if</span> <span class="s1">&#39;evaluate&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;You have to implement the &#39;evaluate&#39; method in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># We also need the method _set_units</span>

        <span class="k">if</span> <span class="s1">&#39;_set_units&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;You have to implement the &#39;_set_units&#39; method in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="c1"># Now parse the documentation of the function which contains the parameter specification</span>

        <span class="c1"># The doc is a YAML document containing among other things the definition of the parameters</span>

        <span class="c1"># Parse it</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">function_definition</span> <span class="o">=</span> <span class="n">my_yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">&#39;__doc__&#39;</span><span class="p">],</span> 
                <span class="n">Loader</span><span class="o">=</span><span class="n">my_yaml</span><span class="o">.</span><span class="n">FullLoader</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">ReaderError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

            <span class="k">raise</span> <span class="n">DocstringIsNotRaw</span><span class="p">(</span><span class="s2">&quot;Docstring parsing has failed. &quot;</span>
                                    <span class="s2">&quot;Did you remember to specify the docstring of </span><span class="si">%s</span><span class="s2"> as raw? &quot;</span>
                                    <span class="s2">&quot;To do that, you have to put a r before the docstring, &quot;</span>
                                    <span class="sd">&#39;&#39;&#39;like in \n\nr&quot;&quot;&quot;\n(docstring)\n&quot;&quot;&quot;\n\ninstead of just\n\n&#39;&#39;&#39;</span>
                                    <span class="sd">&#39;&#39;&#39;&quot;&quot;&quot;\ndocstring\n&quot;&quot;&quot;&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Store the function definition in the type</span>

            <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_function_definition&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_definition</span>

        <span class="c1"># Enforce the presence of a description and of a parameters dictionary</span>

        <span class="k">assert</span> <span class="s2">&quot;description&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">function_definition</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="s2">&quot;You have to provide a &#39;description&#39; token in the &quot;</span> \
            <span class="s2">&quot;documentation of class </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span>

        <span class="k">assert</span> <span class="s2">&quot;parameters&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">function_definition</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="s2">&quot;You have to provide a &#39;parameters&#39; token in the &quot;</span> \
            <span class="s2">&quot;documentation of class </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">name</span>

        <span class="c1"># If there is a latex formula, store it in the type</span>

        <span class="k">if</span> <span class="s1">&#39;latex&#39;</span> <span class="ow">in</span> <span class="n">function_definition</span><span class="p">:</span>

            <span class="c1"># First remove the escaping we did to overcome the limitation of the YAML parser</span>

            <span class="n">latex_formula</span> <span class="o">=</span> <span class="n">function_definition</span><span class="p">[</span><span class="s1">&#39;latex&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">92</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">latex_formula</span> <span class="o">=</span> <span class="n">NO_LATEX_FORMULA</span>

        <span class="c1"># Store latex formula in the type</span>
        <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_latex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">latex_formula</span>

        <span class="c1"># Parse the parameters&#39; dictionary</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function_definition</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;Wrong syntax in &#39;parameters&#39; token. It must be &quot;</span> \
                                                                    <span class="s2">&quot;a dictionary. Refer to the documentation.&quot;</span>

        <span class="c1"># Add the parameters as attribute of the *type*. During the __call__ method below this dictionary will be used</span>
        <span class="c1"># to create a copy of each parameter which will be made available as child of the *instance*.</span>

        <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">parameter_name</span><span class="p">,</span> <span class="n">parameter_definition</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">function_definition</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

            <span class="n">this_parameter</span> <span class="o">=</span> <span class="n">FunctionMeta</span><span class="o">.</span><span class="n">parse_parameter_definition</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">,</span> <span class="n">parameter_definition</span><span class="p">)</span>

            <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_parameters&#39;</span><span class="p">][</span><span class="n">this_parameter</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_parameter</span>

        <span class="c1"># Now perform a minimal check of the &#39;evaluate&#39; function</span>

        <span class="n">variables</span><span class="p">,</span> <span class="n">parameters_in_calling_sequence</span> <span class="o">=</span> <span class="n">FunctionMeta</span><span class="o">.</span><span class="n">check_calling_sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;evaluate&#39;</span><span class="p">,</span>
                                                                                        <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;evaluate&#39;</span><span class="p">],</span>
                                                                                        <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">])</span>

        <span class="c1"># Now check that all the parameters used in &#39;evaluate&#39; are part of the documentation,</span>
        <span class="c1"># and that there are no unused parameters</span>

        <span class="n">set1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parameters_in_calling_sequence</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">set1</span> <span class="o">!=</span> <span class="n">set2</span><span class="p">:</span>

            <span class="c1"># The parameters are different. Figure out who is missing and raise an exception accordingly</span>

            <span class="k">if</span> <span class="n">set1</span> <span class="o">&gt;</span> <span class="n">set2</span><span class="p">:</span>

                <span class="n">missing</span> <span class="o">=</span> <span class="n">set1</span> <span class="o">-</span> <span class="n">set2</span>

                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters </span><span class="si">%s</span><span class="s2"> have init values but are not used in &#39;evaluate&#39; in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="n">missing</span> <span class="o">=</span> <span class="n">set2</span> <span class="o">-</span> <span class="n">set1</span>

                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters </span><span class="si">%s</span><span class="s2"> are used in &#39;evaluate&#39; but do not have init values in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> \
                      <span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>

            <span class="k">raise</span> <span class="n">FunctionDefinitionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Figure out the dimensionality of this function</span>

        <span class="n">n_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span>

        <span class="c1"># Store the dimensionality in the *type*</span>

        <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_n_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_dim</span>

        <span class="c1"># Now add the constructor to the class, if it does not provide one</span>
        <span class="c1"># You shouldn&#39;t usually provide a constructor, that&#39;s only for advance uses</span>
        <span class="c1"># like the TemplateModel</span>

        <span class="k">if</span> <span class="s1">&#39;_custom_init_&#39;</span> <span class="ow">in</span> <span class="n">dct</span><span class="p">:</span>

            <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;__init__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_custom_init_&#39;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;__init__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FunctionMeta</span><span class="o">.</span><span class="n">class_init</span>

        <span class="c1"># Finally, add the info() method to the type so that it can be called even without instancing the class</span>

        <span class="k">def</span> <span class="nf">info</span><span class="p">():</span>

            <span class="n">repr_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

            <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_definition</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="s1">&#39;latex&#39;</span> <span class="ow">in</span> <span class="n">function_definition</span><span class="p">:</span>
                <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;formula&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">function_definition</span><span class="p">[</span><span class="s1">&#39;latex&#39;</span><span class="p">]</span>

            <span class="c1"># Add the description of each parameter and their current value</span>
            <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;default parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">parameter_name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>

                <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;default parameters&#39;</span><span class="p">][</span><span class="n">parameter_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;_parameters&#39;</span><span class="p">][</span><span class="n">parameter_name</span><span class="p">]</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">has_ipython</span><span class="p">:</span>

                <span class="n">display</span><span class="p">(</span><span class="n">HTML</span><span class="p">(</span><span class="n">dict_to_list</span><span class="p">(</span><span class="n">repr_dict</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="nb">print</span><span class="p">(</span><span class="n">dict_to_list</span><span class="p">(</span><span class="n">repr_dict</span><span class="p">,</span> <span class="n">html</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="c1"># Now call the __new__ of the &quot;type&quot; class (which then will call the __init__ of this metaclass)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">FunctionMeta</span><span class="p">,</span> <span class="n">mcs</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span>

<div class="viewcode-block" id="FunctionMeta.__init__"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.FunctionMeta.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">):</span>

        <span class="c1"># This is the MetaClass init, which is called after the __new__ is done</span>

        <span class="c1"># Store the name of the function in the type</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># Add this as a known function</span>

        <span class="n">_known_functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">cls</span>

        <span class="c1"># Finally call the init of the type class</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">FunctionMeta</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">dct</span><span class="p">)</span></div>

<div class="viewcode-block" id="FunctionMeta.class_init"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.FunctionMeta.class_init">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">class_init</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># This is what is going to be called as the __init__ of the class, every time a new instance</span>
        <span class="c1"># is created</span>

        <span class="c1"># Create a copy of the parameters dictionary which is in the type,</span>
        <span class="c1"># otherwise every instance would share the same dictionary</span>

        <span class="n">copy_of_parameters</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># Fill it by duplicating the parameters contained in the dictionary in the type</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

            <span class="n">copy_of_parameters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>

            <span class="c1"># If the user has specified a value in the constructor, update the</span>
            <span class="c1"># corresponding parameters value. This allow to use a constructor as:</span>
            <span class="c1"># my_powerlaw = powerlaw(logK=1.0, index=-2)</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>

                <span class="n">copy_of_parameters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Now check that all the parameters specified in the kwargs are actually parameters of this function</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>

            <span class="k">try</span><span class="p">:</span>

                <span class="n">copy_of_parameters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>

                <span class="k">raise</span> <span class="n">UnknownParameter</span><span class="p">(</span><span class="s2">&quot;You specified an init value for </span><span class="si">%s</span><span class="s2">, which is not a &quot;</span>
                                       <span class="s2">&quot;parameter of function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_name</span><span class="p">))</span>

        <span class="c1"># Now call the init of the corresponding class</span>
        <span class="n">n_dim</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_n_dim</span>

        <span class="k">if</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">Function1D</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">,</span>
                                <span class="n">copy_of_parameters</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            <span class="n">Function2D</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">,</span>
                                <span class="n">copy_of_parameters</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">n_dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

            <span class="n">Function3D</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span>
                                <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">,</span>
                                <span class="n">copy_of_parameters</span><span class="p">)</span>

        <span class="c1"># Last, if the class provides a setup method, call it</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="s2">&quot;_setup&quot;</span><span class="p">):</span>

            <span class="n">instance</span><span class="o">.</span><span class="n">_setup</span><span class="p">()</span></div>

<div class="viewcode-block" id="FunctionMeta.check_calling_sequence"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.FunctionMeta.check_calling_sequence">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_calling_sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">function_name</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">possible_variables</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the calling sequence for the function looking for the variables specified.</span>
<span class="sd">        One or more of the variables can be in the calling sequence. Note that the</span>
<span class="sd">        order of the variables will be enforced.</span>
<span class="sd">        It will also enforce that the first parameter in the calling sequence is called &#39;self&#39;.</span>

<span class="sd">        :param function: the function to check</span>
<span class="sd">        :param possible_variables: a list of variables to check, The order is important, and will be enforced</span>
<span class="sd">        :return: a tuple containing the list of found variables, and the name of the other parameters in the calling</span>
<span class="sd">        sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get calling sequence</span>

        <span class="c1"># If the function has been memoized, it will have a &quot;input_object&quot; member</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">calling_sequence</span> <span class="o">=</span> <span class="n">_py2to3_getargspec</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">input_object</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>

        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>

            <span class="c1"># This might happen if the function is without memoization</span>

            <span class="n">calling_sequence</span> <span class="o">=</span> <span class="n">_py2to3_getargspec</span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="o">.</span><span class="n">args</span>

        <span class="k">assert</span> <span class="n">calling_sequence</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s2">&quot;Wrong syntax for &#39;evaluate&#39; in </span><span class="si">%s</span><span class="s2">. The first argument &quot;</span> \
                                              <span class="s2">&quot;should be called &#39;self&#39;.&quot;</span> <span class="o">%</span> <span class="n">name</span>

        <span class="c1"># Figure out how many variables are used</span>

        <span class="n">variables</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">calling_sequence</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">possible_variables</span><span class="p">]</span>

        <span class="c1"># Check that they actually make sense. They must be used in the same order</span>
        <span class="c1"># as specified in possible_variables</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;The name of the variables for &#39;evaluate&#39; in </span><span class="si">%s</span><span class="s2"> must be one or more &quot;</span> \
                                   <span class="s2">&quot;among </span><span class="si">%s</span><span class="s2">, instead of </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                                       <span class="n">possible_variables</span><span class="p">),</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">variables</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">variables</span> <span class="o">!=</span> <span class="n">possible_variables</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)]:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;The variables </span><span class="si">%s</span><span class="s2"> are out of order in &#39;</span><span class="si">%s</span><span class="s2">&#39; of </span><span class="si">%s</span><span class="s2">. Should be </span><span class="si">%s</span><span class="s2">.&quot;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">variables</span><span class="p">),</span> <span class="n">function_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">possible_variables</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">variables</span><span class="p">)]))</span>

        <span class="n">other_parameters</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">calling_sequence</span> <span class="k">if</span> <span class="n">var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span> <span class="ow">and</span> <span class="n">var</span> <span class="o">!=</span> <span class="s1">&#39;self&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">variables</span><span class="p">,</span> <span class="n">other_parameters</span></div>

<div class="viewcode-block" id="FunctionMeta.parse_parameter_definition"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.FunctionMeta.parse_parameter_definition">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">parse_parameter_definition</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">par_name</span><span class="p">,</span> <span class="n">definition</span><span class="p">):</span>

        <span class="c1"># Parse definition of parameter</span>

        <span class="c1"># Enforce the presence of attributes &#39;value&#39; and &#39;desc&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;initial value&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FunctionDefinitionError</span><span class="p">(</span><span class="s2">&quot;Error for parameter </span><span class="si">%s</span><span class="s2"> of function </span><span class="si">%s</span><span class="s2">: value for parameter must be&quot;</span>
                                          <span class="s2">&quot; specified&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par_name</span><span class="p">,</span> <span class="n">func_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="s1">&#39;desc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">FunctionDefinitionError</span><span class="p">(</span><span class="s2">&quot;Error for parameter </span><span class="si">%s</span><span class="s2"> of function </span><span class="si">%s</span><span class="s2">: desc for parameter must be&quot;</span>
                                          <span class="s2">&quot; specified&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">par_name</span><span class="p">,</span> <span class="n">func_name</span><span class="p">))</span>

        <span class="c1"># Fetch attributes</span>

        <span class="c1"># Use unitless parameters when building the function, if no unit is specified, otherwise</span>
        <span class="c1"># use that unit</span>
        <span class="k">if</span> <span class="s1">&#39;unit&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span> <span class="ow">or</span> <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>

            <span class="n">du</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">du</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">definition</span><span class="p">[</span><span class="s1">&#39;unit&#39;</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">_parse_value</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>

                <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">return</span> <span class="kc">None</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">_parse_value</span><span class="p">(</span><span class="n">definition</span><span class="p">[</span><span class="s1">&#39;initial value&#39;</span><span class="p">])</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;desc&#39;</span><span class="p">]</span>

        <span class="c1"># Optional attributes are either None if not specified, or the value specified</span>

        <span class="n">min_value</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="s1">&#39;min&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span> <span class="k">else</span> <span class="n">_parse_value</span><span class="p">(</span><span class="n">definition</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]))</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="p">(</span>
            <span class="kc">None</span> <span class="k">if</span> <span class="s1">&#39;max&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span> <span class="k">else</span> <span class="n">_parse_value</span><span class="p">(</span><span class="n">definition</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]))</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="s1">&#39;delta&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span> <span class="k">else</span> <span class="n">_parse_value</span><span class="p">(</span>
            <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;delta&#39;</span><span class="p">]))</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="n">du</span>

        <span class="c1"># A parameter can be fixed by using fix=yes, otherwise it is free by default</span>

        <span class="n">free</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span> <span class="k">if</span> <span class="s1">&#39;fix&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span> <span class="k">else</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span>
            <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;fix&#39;</span><span class="p">]))</span>

        <span class="n">is_normalization</span> <span class="o">=</span> <span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="s1">&#39;is_normalization&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span> <span class="k">else</span> <span class="nb">bool</span><span class="p">(</span>
            <span class="n">definition</span><span class="p">[</span><span class="s1">&#39;is_normalization&#39;</span><span class="p">]))</span>

        <span class="n">transformation</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span> <span class="k">if</span> <span class="s1">&#39;transformation&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definition</span> <span class="k">else</span>
                          <span class="n">get_transformation</span><span class="p">(</span><span class="n">definition</span><span class="p">[</span><span class="s1">&#39;transformation&#39;</span><span class="p">]))</span>

        <span class="n">new_parameter</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">par_name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">min_value</span><span class="o">=</span><span class="n">min_value</span><span class="p">,</span> <span class="n">max_value</span><span class="o">=</span><span class="n">max_value</span><span class="p">,</span>
                                  <span class="n">delta</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">,</span> <span class="n">free</span><span class="o">=</span><span class="n">free</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">is_normalization</span><span class="o">=</span><span class="n">is_normalization</span><span class="p">,</span>
                                  <span class="n">transformation</span><span class="o">=</span><span class="n">transformation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_parameter</span></div></div>


<div class="viewcode-block" id="Function"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function">[docs]</a><span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic Function class. Will be subclassed in Function1D, Function2D and Function3D.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Function.__init__"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">function_definition</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># I use default values only to avoid warnings from pycharm and other software about the</span>
        <span class="c1"># calling sequence of this contructor. We actually need to enforce its proper use,</span>
        <span class="c1"># with this assert</span>

        <span class="k">assert</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">function_definition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1"># Set up the node</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Function</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Store name, number of dimensions and the latex formula</span>

        <span class="c1"># Store also the function definition</span>

        <span class="k">assert</span> <span class="s1">&#39;description&#39;</span> <span class="ow">in</span> <span class="n">function_definition</span><span class="p">,</span> <span class="s2">&quot;Function definition must contain a description&quot;</span>

        <span class="k">if</span> <span class="s1">&#39;latex&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">function_definition</span><span class="p">:</span>

            <span class="n">function_definition</span><span class="p">[</span><span class="s1">&#39;latex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;$n.a.$&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_function_definition</span> <span class="o">=</span> <span class="n">function_definition</span>

        <span class="c1"># Add the parameters as children. Since the name of the key in the dictionary might</span>
        <span class="c1"># be different than the actual name of the parameter, use the .add_child method instead</span>
        <span class="c1"># of the add_children method</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">child_name</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">child_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span>

            <span class="c1"># Add the parameter as a child of the function</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_add_child</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="c1"># Now generate a unique identifier (UUID) in a thread safe, multi-processing safe</span>
        <span class="c1"># way. This is used for example in the CompositeFunction class to keep track of the different</span>
        <span class="c1"># instances of the same function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_uuid</span><span class="p">())</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="c1"># Normal functions are able to change units, while some specific ones (such as the one from XSpec) are not.</span>
        <span class="c1"># In this second case, this variable will contain a tuple (x_unit, y_unit), but by default it should be</span>
        <span class="c1"># None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_units</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_prior</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: number of dimensions for this function (1, 2 or 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_n_dim</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">free_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary of free parameters for this function</span>

<span class="sd">        :return: dictionary of free parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">free_parameters</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">free_parameters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_free_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True or False depending on if any parameters are free</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">free</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Function._generate_uuid"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function._generate_uuid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_generate_uuid</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a unique identifier for this function.</span>

<span class="sd">        :return: the UUID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">(</span><span class="nb">bytes</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">version</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function.has_fixed_units"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.has_fixed_units">[docs]</a>    <span class="k">def</span> <span class="nf">has_fixed_units</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this function cannot change units, which is the case only for very specific functions (like</span>
<span class="sd">        models from foreign libraries like Xspec)</span>

<span class="sd">        :return: True or False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fixed_units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_prior</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns False by default and must be overrided in the prior functions.</span>

<span class="sd">        :return: True or False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_prior</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fixed_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns the fixed units if has_fixed_units is True (see has_fixed_units)</span>

<span class="sd">            :return: None, or a tuple (x_unit, y_unit)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fixed_units</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">description</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a description for this function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span>

    <span class="c1"># Add a property returning the parameters dictionary</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">latex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the LaTEX formula for this function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">[</span><span class="s1">&#39;latex&#39;</span><span class="p">]</span>

    <span class="c1"># Define now all the operators which allow to combine functions. Each operator will return a new</span>
    <span class="c1"># instance of a CompositeFunction, which can then be used as a function on its own</span>

<div class="viewcode-block" id="Function.of"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.of">[docs]</a>    <span class="k">def</span> <span class="nf">of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">another_function</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compose this function with another as in this_function(another_function(x))</span>
<span class="sd">        :param another_function: another function to compose with the current one</span>
<span class="sd">        :return: a composite function instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">another_function</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;*-&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;abs&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;**&#39;</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">)</span>

    <span class="fm">__radd__</span> <span class="o">=</span> <span class="fm">__add__</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">)</span>

        <span class="c1"># If the other instance is a function (and not a number), flag it so its units will be made dimensionless</span>
        <span class="c1"># in the set_units method of the composite function</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_instance</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_fixed_units</span><span class="p">():</span>

                <span class="c1"># This is likely a XSpec model. The multiplication of two models with units will give the wrong</span>
                <span class="c1"># units to the results. So, depending on the type of the first and second model, we need to adjust</span>
                <span class="c1"># their units so that the result will keep the right units.</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fixed_units</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">:</span>

                    <span class="c1"># This function has fixed unit and is not dimensionless (likely an additive XSpec model).</span>
                    <span class="c1"># We need to make the other function dimensionless so that the multiplication of them will keep</span>
                    <span class="c1"># the right units</span>

                    <span class="n">other_instance</span><span class="o">.</span><span class="n">_make_dimensionless</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># This function has fixed unit, but it is dimensionless (likely a multiplicative XSpec model)</span>
                    <span class="c1"># The other function should keep its units, so we flag self instead</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_make_dimensionless</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="c1"># However, if also the other function has fixed dimension and it is dimensionless</span>
                    <span class="c1"># (likely another XSpec multiplicative model) we need to flag that as well</span>
                    <span class="k">if</span> <span class="n">other_instance</span><span class="o">.</span><span class="n">has_fixed_units</span><span class="p">()</span> <span class="ow">and</span> \
                        <span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">other_instance</span><span class="o">.</span><span class="n">fixed_units</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">):</span>
                        <span class="n">other_instance</span><span class="o">.</span><span class="n">_make_dimensionless</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="c1"># Now we need to flag the composite function as fixed units and dimensionless</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">_fixed_units</span> <span class="o">=</span> <span class="n">other_instance</span><span class="o">.</span><span class="n">fixed_units</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># We need to make the other instance dimensionless so that this function (which is not dimensionless)</span>
                <span class="c1"># multiplied by the other function (which we will make dimensionless) will give the right units as</span>
                <span class="c1"># the results</span>

                <span class="n">other_instance</span><span class="o">.</span><span class="n">_make_dimensionless</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">c</span>

    <span class="fm">__rmul__</span> <span class="o">=</span> <span class="fm">__mul__</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">)</span>

        <span class="c1"># If the other instance is a function (and not a number), flag it so its units will be made dimensionless</span>
        <span class="c1"># in the set_units method of the composite function</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_instance</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_fixed_units</span><span class="p">():</span>

                <span class="c1"># This is likely a XSpec model. Division is not supported.</span>

                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s2">&quot;Division for XSpec models is not supported&quot;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># We need to make the other instance dimensionless</span>

                <span class="n">other_instance</span><span class="o">.</span><span class="n">_make_dimensionless</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">c</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">CompositeFunction</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">other_instance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="fm">__truediv__</span> <span class="o">=</span> <span class="n">__div__</span>
    <span class="fm">__rtruediv__</span> <span class="o">=</span> <span class="n">__rdiv__</span>

    <span class="k">def</span> <span class="nf">_repr__base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rich_output</span><span class="p">):</span>

        <span class="n">repr_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="s1">&#39;latex&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">:</span>

            <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;formula&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">[</span><span class="s1">&#39;latex&#39;</span><span class="p">]</span>

        <span class="c1"># Add the description of each parameter and their current value</span>
        <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">():</span>

            <span class="n">repr_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">][</span><span class="n">parameter</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">dict_to_list</span><span class="p">(</span><span class="n">repr_dict</span><span class="p">,</span> <span class="n">rich_output</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uuid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the ID of the current function. The ID is used by the CompositeFunction class to keep track of the</span>
<span class="sd">        unique instances of each function. It should not be used by the user for any specific purpose.</span>

<span class="sd">        :return: (none)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span>

<div class="viewcode-block" id="Function.duplicate"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.duplicate">[docs]</a>    <span class="k">def</span> <span class="nf">duplicate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a copy of the current function with all the parameters equal to the current value</span>

<span class="sd">        :return: a new copy of the function</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a copy</span>

        <span class="n">function_copy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">function_copy</span></div>

<div class="viewcode-block" id="Function.get_boundaries"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.get_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">get_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the boundaries of this function. By default there is no boundary, but subclasses can</span>
<span class="sd">        override this.</span>

<span class="sd">        :return: a tuple of tuples containing the boundaries for each coordinate (ra_min, ra_max), (dec_min, dec_max)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You have to implement this&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You have to implement this&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Function.fast_call"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.fast_call">[docs]</a>    <span class="k">def</span> <span class="nf">fast_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You have to implement this&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function.evaluate_at"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.evaluate_at">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">parameter_specification</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the function at the given x(,y,z) for the provided parameters, explicitly provided as part of the</span>
<span class="sd">        parameter_specification keywords.</span>

<span class="sd">        :param *args:</span>
<span class="sd">        :param **parameter_specification:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set the parameters to the provided values</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">parameter_specification</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_get_child</span><span class="p">(</span>
                <span class="n">parameter</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">parameter_specification</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function.get_total_spatial_integral"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function.get_total_spatial_integral">[docs]</a>    <span class="k">def</span> <span class="nf">get_total_spatial_integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the total integral (for 2D functions) or the integral over the spatial components (for 3D functions).</span>
<span class="sd">        needs to be implemented in subclasses.</span>

<span class="sd">        :return: an array of values of the integral (same dimension as z).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You have to implement this&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Function1D"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function1D">[docs]</a><span class="k">class</span> <span class="nc">Function1D</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>

<div class="viewcode-block" id="Function1D.__init__"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function1D.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">function_definition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">function_definition</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Function1D.evaluate"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function1D.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You have to re-implement this&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function1D.set_units"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function1D.set_units">[docs]</a>    <span class="k">def</span> <span class="nf">set_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_x_unit</span><span class="p">,</span> <span class="n">in_y_unit</span><span class="p">):</span>

        <span class="c1"># Transform None in input to &#39;&#39;, so that u.Unit() will generate a dimensionless unit</span>

        <span class="n">in_x_unit</span> <span class="o">=</span> <span class="n">in_x_unit</span> <span class="k">if</span> <span class="n">in_x_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">in_y_unit</span> <span class="o">=</span> <span class="n">in_y_unit</span> <span class="k">if</span> <span class="n">in_y_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># Get a Unit instance from the inputs</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">in_x_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_x_unit</span><span class="p">)</span>
            <span class="n">in_y_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_y_unit</span><span class="p">)</span>

        <span class="k">except</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not get a Unit instance from provided units </span><span class="si">%s</span><span class="s2"> when setting units &quot;</span>
                            <span class="s2">&quot;for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">((</span><span class="n">in_x_unit</span><span class="p">,</span> <span class="n">in_y_unit</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="c1"># Now call the underlying method to set units, which is defined by each function</span>
        <span class="n">new_units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_units</span><span class="p">(</span><span class="n">in_x_unit</span><span class="p">,</span> <span class="n">in_y_unit</span><span class="p">)</span>

        <span class="c1"># Store the units.</span>
        <span class="c1"># NOTE: the previous call to _set_units might return new units in special cases</span>
        <span class="c1"># (for example Xspec functions). So it is critical that we store them in the class&#39; attributes</span>
        <span class="c1"># after the call to _set_units</span>

        <span class="k">if</span> <span class="n">new_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">new_x_unit</span><span class="p">,</span> <span class="n">new_y_unit</span> <span class="o">=</span> <span class="n">new_units</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span> <span class="o">=</span> <span class="n">new_x_unit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span> <span class="o">=</span> <span class="n">new_y_unit</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span> <span class="o">=</span> <span class="n">in_x_unit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span> <span class="o">=</span> <span class="n">in_y_unit</span></div>

    <span class="k">def</span> <span class="nf">_set_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_unit</span><span class="p">,</span> <span class="n">y_unit</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="c1"># This will be overridden by derived classes</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;You have to implement the method _set_units for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The unit of the independent variable</span>
<span class="sd">        :return: a astropy.Unit instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The unit of the dependent variable</span>
<span class="sd">        :return: a astropy.Unit instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="c1"># This method&#39;s code violates explicitly duck typing. The reason is that astropy.units introduce a very</span>
        <span class="c1"># significant overload on any computation. For this reason we treat differently the case with units from</span>
        <span class="c1"># the case without units, so that the latter case remains fast. Also, transforming an input</span>
        <span class="c1"># which is not an array into an array introduce a significant overload (10 microseconds or so), so we perform</span>
        <span class="c1"># this transformation only when strictly required</span>

        <span class="c1"># NOTE: for a single quantity such as q = (1.0 * u.keV), isinstance(q, np.ndarray) returns True</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="c1"># We have an array as input (or a single quantity)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>

                <span class="c1"># This is a normal array, let&#39;s use the fast call (without units)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_call</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># This is an array with units or a single quantity, let&#39;s use the slow call which preserves units</span>

                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;In order to use units you need to use the function as a spectrum or &quot;</span> \
                                                <span class="s2">&quot;as something else, or you need to explicitly set the units.&quot;</span>

                <span class="c1"># we want to make sure this is an array</span>

                <span class="n">new_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_with_units</span><span class="p">(</span><span class="n">new_input</span><span class="p">)</span>

                <span class="c1"># Now convert to the expected y unit and return a astropy.Quantity by multiplying by the right unit</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_unit</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># This is either a single number or a list</span>

            <span class="c1"># Transform the input to an array of floats. If x is a single number, this will be an array of size 1</span>

            <span class="n">new_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Compute the function</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fast_call</span><span class="p">(</span><span class="n">new_input</span><span class="p">)</span>

            <span class="c1"># Now remove all dimensions of size 1. For example, an array of shape (1,) will become a single number,</span>
            <span class="c1"># so that if the input was a single number, also the output will be a single number</span>

            <span class="n">sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

            <span class="c1"># if this is still a list after all this work this its</span>
            <span class="c1"># shape will be</span>
            <span class="k">if</span> <span class="n">sq</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>

                <span class="k">return</span> <span class="n">sq</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># this is a single number and we assume it is a float</span>

                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">sq</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_with_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="c1"># Gather the current parameters&#39; values with units</span>
        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;as_quantity&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">()))</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                <span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">spectral</span><span class="p">()),</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

            <span class="c1"># see if this is a dimensionless function</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_fixed_units</span><span class="p">():</span>

                <span class="k">try</span><span class="p">:</span>

                    <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_unit</span><span class="p">),</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

                <span class="k">except</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">:</span>

                    <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;Looks like you didn&#39;t provide all the units, or you provided the wrong ones, when &quot;</span>
                                       <span class="s2">&quot;calling function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;Looks like you didn&#39;t provide all the units, or you provided the wrong ones, when &quot;</span>
                                   <span class="s2">&quot;calling function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">results</span>

<div class="viewcode-block" id="Function1D.fast_call"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function1D.fast_call">[docs]</a>    <span class="nd">@memoize</span>
    <span class="k">def</span> <span class="nf">fast_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>

        <span class="c1"># Gather the current parameters&#39; values without units, which means that the whole computation</span>
        <span class="c1"># will be without units, with a big speed gain (~10x)</span>

        <span class="c1"># NOTE: it is important to use value, and not _value, to support linking</span>

        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">()))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function1D.get_boundaries"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function1D.get_boundaries">[docs]</a>    <span class="k">def</span> <span class="nf">get_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the boundaries of this function. By default there is no boundary, but subclasses can</span>
<span class="sd">        override this.</span>

<span class="sd">        :return: a tuple of tuples containing the boundaries for each coordinate (ra_min, ra_max), (dec_min, dec_max)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="n">DesignViolation</span><span class="p">(</span><span class="s2">&quot;Cannot call get_boundaries() on a 1d function&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Function1D.local_spectral_index"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function1D.local_spectral_index">[docs]</a>    <span class="k">def</span> <span class="nf">local_spectral_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;TODO describe function</span>
<span class="sd">        </span>
<span class="sd">        :param x: </span>
<span class="sd">        :type energy: </span>
<span class="sd">        :param epsilon: </span>
<span class="sd">        :type epsilon: </span>
<span class="sd">        :returns: </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_local_deriv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span></div></div>
    
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span>
<span class="k">def</span> <span class="nf">_local_deriv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>  <span class="n">epsilon</span><span class="p">):</span>

    <span class="k">return</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="mf">1.</span> <span class="o">+</span> <span class="n">epsilon</span><span class="p">)</span>
    
<div class="viewcode-block" id="Function2D"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function2D">[docs]</a><span class="k">class</span> <span class="nc">Function2D</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>

<div class="viewcode-block" id="Function2D.__init__"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function2D.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">function_definition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">function_definition</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Function2D.evaluate"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function2D.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You have to re-implement this&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function2D.set_units"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function2D.set_units">[docs]</a>    <span class="k">def</span> <span class="nf">set_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_x_unit</span><span class="p">,</span> <span class="n">in_y_unit</span><span class="p">,</span> <span class="n">in_z_unit</span><span class="p">):</span>

        <span class="c1"># Change None to &#39;&#39; for the inputs so that the following u.Unit construction will generate a dimensionless</span>
        <span class="c1"># unit (it would fail with None)</span>

        <span class="n">in_x_unit</span> <span class="o">=</span> <span class="n">in_x_unit</span> <span class="k">if</span> <span class="n">in_x_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">in_y_unit</span> <span class="o">=</span> <span class="n">in_y_unit</span> <span class="k">if</span> <span class="n">in_y_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">in_z_unit</span> <span class="o">=</span> <span class="n">in_z_unit</span> <span class="k">if</span> <span class="n">in_z_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">in_x_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_x_unit</span><span class="p">)</span>
            <span class="n">in_y_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_y_unit</span><span class="p">)</span>
            <span class="n">in_z_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_z_unit</span><span class="p">)</span>

        <span class="k">except</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not get a Unit instance from provided units when setting units &quot;</span>
                            <span class="s2">&quot;for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Store the Unit instances</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span> <span class="o">=</span> <span class="n">in_x_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span> <span class="o">=</span> <span class="n">in_y_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span> <span class="o">=</span> <span class="n">in_z_unit</span>

        <span class="c1"># Now call the underlying method to set units, which is defined by each function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_unit</span><span class="p">,</span> <span class="n">y_unit</span><span class="p">,</span> <span class="n">z_unit</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="c1"># This will be overridden by derived classes</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;You have to implement the method _set_units for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># This method&#39;s code violates explicitly duck typing. The reason is that astropy.units introduce a very</span>
        <span class="c1"># significant overload on any computation. For this reason we treat differently the case with units from</span>
        <span class="c1"># the case without units, so that the latter case remains fast. Also, transforming an input</span>
        <span class="c1"># which is not an array into an array introduce a significant overload (10 microseconds or so), so we perform</span>
        <span class="c1"># this transformation only when strictly required</span>

        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="s2">&quot;You have to use the same type for x and y&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="c1"># We have an array or a quantity as input</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>

                <span class="c1"># This is a normal array, let&#39;s use the fast call (without units)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_without_units</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># This is an array with units or a single quantity, let&#39;s use the slow call which preserves units</span>

                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_with_units</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

                <span class="c1"># Now convert to the expected z unit and remove useless dimensions</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_unit</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># This is either a single number or a list</span>

            <span class="c1"># Transform the input to an array of floats</span>

            <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Compute the function</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_without_units</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">)</span>

            <span class="c1"># Now remove all dimensions of size 1. For example, an array of shape (1,) will become a single number.</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_with_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>

        <span class="c1"># Gather the current parameters&#39; values with units</span>

        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;as_quantity&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">()))</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;Looks like you didn&#39;t provide all the units, or you provided the wrong ones, when &quot;</span>
                               <span class="s2">&quot;calling function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@memoize</span>
    <span class="k">def</span> <span class="nf">_call_without_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>

        <span class="c1"># Gather the current parameters&#39; values without units, which means that the whole computation</span>
        <span class="c1"># will be without units, with a big speed gain (~10x)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">()))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="Function3D"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function3D">[docs]</a><span class="k">class</span> <span class="nc">Function3D</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>

<div class="viewcode-block" id="Function3D.__init__"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function3D.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">function_definition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">function_definition</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w_unit</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Function3D.evaluate"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function3D.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You have to re-implement this&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Function3D.set_units"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.Function3D.set_units">[docs]</a>    <span class="k">def</span> <span class="nf">set_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_x_unit</span><span class="p">,</span> <span class="n">in_y_unit</span><span class="p">,</span> <span class="n">in_z_unit</span><span class="p">,</span> <span class="n">in_w_unit</span><span class="p">):</span>

        <span class="c1"># Change None to &#39;&#39; for the inputs so that the following u.Unit construction will generate a dimensionless</span>
        <span class="c1"># unit (it would fail with None)</span>

        <span class="n">in_x_unit</span> <span class="o">=</span> <span class="n">in_x_unit</span> <span class="k">if</span> <span class="n">in_x_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">in_y_unit</span> <span class="o">=</span> <span class="n">in_y_unit</span> <span class="k">if</span> <span class="n">in_y_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">in_z_unit</span> <span class="o">=</span> <span class="n">in_z_unit</span> <span class="k">if</span> <span class="n">in_z_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">in_w_unit</span> <span class="o">=</span> <span class="n">in_w_unit</span> <span class="k">if</span> <span class="n">in_w_unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># Get instances of Unit</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">in_x_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_x_unit</span><span class="p">)</span>
            <span class="n">in_y_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_y_unit</span><span class="p">)</span>
            <span class="n">in_z_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_z_unit</span><span class="p">)</span>
            <span class="n">in_w_unit</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">in_w_unit</span><span class="p">)</span>

        <span class="k">except</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Could not get a Unit instance from provided units when setting units &quot;</span>
                            <span class="s2">&quot;for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Store the Unit instances</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span> <span class="o">=</span> <span class="n">in_x_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span> <span class="o">=</span> <span class="n">in_y_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span> <span class="o">=</span> <span class="n">in_z_unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w_unit</span> <span class="o">=</span> <span class="n">in_w_unit</span>

        <span class="c1"># Now call the underlying method to set units, which is defined by each function</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_units</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w_unit</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_unit</span><span class="p">,</span> <span class="n">y_unit</span><span class="p">,</span> <span class="n">z_unit</span><span class="p">,</span> <span class="n">w_unit</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="c1"># This will be overridden by derived classes</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;You have to implement the method _set_units for function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">x_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">y_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">z_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_unit</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">w_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w_unit</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>

        <span class="c1"># This method&#39;s code violates explicitly duck typing. The reason is that astropy.units introduce a very</span>
        <span class="c1"># significant overload on any computation. For this reason we treat differently the case with units from</span>
        <span class="c1"># the case without units, so that the latter case remains fast. Also, transforming an input</span>
        <span class="c1"># which is not an array into an array introduce a significant overload (10 microseconds or so), so we perform</span>
        <span class="c1"># this transformation only when strictly required</span>

        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span>
            <span class="n">z</span><span class="p">),</span> <span class="s2">&quot;You have to use the same type for x, y and z&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>

            <span class="c1"># We have an array as input</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>

                <span class="c1"># This is a normal array, let&#39;s use the fast call (without units)</span>

                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_without_units</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># This is an array with units or a single quantity, let&#39;s use the slow call which preserves units</span>

                <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_with_units</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

                <span class="c1"># Now convert to the expected w unit and remove useless dimensions</span>

                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_unit</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">w_unit</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># This is either a single number or a list</span>
            <span class="c1"># Transform the input to an array of floats</span>

            <span class="n">new_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># Compute the function</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_without_units</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">new_z</span><span class="p">)</span>

            <span class="c1"># Now remove all dimensions of size 1. For example, an array of shape (1,) will become a single number.</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_with_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>

        <span class="c1"># Gather the current parameters&#39; values with units</span>

        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;as_quantity&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">()))</span>

        <span class="k">try</span><span class="p">:</span>

            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

            <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitsError</span><span class="p">(</span><span class="s2">&quot;Looks like you didn&#39;t provide all the units, or you provided the wrong ones, when &quot;</span>
                               <span class="s2">&quot;calling function </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">results</span>

    <span class="nd">@memoize</span>
    <span class="k">def</span> <span class="nf">_call_without_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>

        <span class="c1"># Gather the current parameters&#39; values without units, which means that the whole computation</span>
        <span class="c1"># will be without units, with a big speed gain (~10x)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_children</span><span class="p">()))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span></div>


<span class="c1">##########################</span>
<span class="c1"># Composite function stuff</span>
<span class="c1">##########################</span>

<span class="c1"># Codes to indicate to Composite Function the operation between two functions</span>
<span class="n">_operations</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">,</span>
               <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">,</span>
               <span class="s1">&#39;*-&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">negative</span><span class="p">,</span>
               <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span>
               <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">,</span>
               <span class="s1">&#39;**&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">,</span>
               <span class="s1">&#39;abs&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span>
               <span class="s1">&#39;of&#39;</span><span class="p">:</span> <span class="s1">&#39;compose&#39;</span><span class="p">}</span>


<span class="c1"># These methods need to be here to overcome the limitation of pickle with methods of classes</span>

<span class="k">def</span> <span class="nf">_cf_evaluate_func_func</span><span class="p">(</span><span class="n">np_operator</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Evaluate for when both elements are functions</span>

    <span class="k">return</span> <span class="n">np_operator</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">f2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_cf_evaluate_func_number</span><span class="p">(</span><span class="n">np_operator</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Evaluate for when element 1 is a function and element 2 is a number</span>

    <span class="k">return</span> <span class="n">np_operator</span><span class="p">(</span><span class="n">f1</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="n">f2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cf_evaluate_number_func</span><span class="p">(</span><span class="n">np_operator</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># Evaluate for when element 2 is a function and element 1 is a number</span>

    <span class="k">return</span> <span class="n">np_operator</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_cf_evaluate_func_of_func</span><span class="p">(</span><span class="n">np_operator</span><span class="p">,</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">f2</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">f1</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>


<div class="viewcode-block" id="CompositeFunction"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.CompositeFunction">[docs]</a><span class="k">class</span> <span class="nc">CompositeFunction</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>

<div class="viewcode-block" id="CompositeFunction.__init__"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.CompositeFunction.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">function_or_scalar_1</span><span class="p">,</span> <span class="n">function_or_scalar_2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">assert</span> <span class="n">operation</span> <span class="ow">in</span> <span class="n">_operations</span><span class="p">,</span> <span class="s2">&quot;Do not know operation </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">operation</span>

        <span class="c1"># Save this to make the class pickeable (see the __setstate__ and __getstate__ methods)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calling_sequence</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">operation</span><span class="p">,</span> <span class="n">function_or_scalar_1</span><span class="p">,</span> <span class="n">function_or_scalar_2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_requested_x_unit</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_requested_y_unit</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_operation</span> <span class="o">=</span> <span class="n">operation</span>

        <span class="c1"># Set the new __call__ according to the type of the elements in the expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decide_evaluate_type</span><span class="p">()</span>

        <span class="c1"># Save a description, but using the unique IDs of the functions involved, to keep track</span>
        <span class="c1"># of where they appear in the expression</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_uuid_expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_uuid_expression</span><span class="p">(</span>
            <span class="n">operation</span><span class="p">,</span> <span class="n">function_or_scalar_1</span><span class="p">,</span> <span class="n">function_or_scalar_2</span><span class="p">)</span>

        <span class="c1"># Makes the list of unique functions which compose this composite function.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="p">[</span><span class="n">function_or_scalar_1</span><span class="p">,</span> <span class="n">function_or_scalar_2</span><span class="p">]:</span>

            <span class="c1"># Check whether this is already a composite function. If it is, add the functions contained</span>
            <span class="c1"># in it</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">CompositeFunction</span><span class="p">):</span>

                <span class="k">for</span> <span class="n">sub_function</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">sub_function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">:</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_function</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>

                <span class="c1"># This is a simple function. Add it only if it is not there already (avoid duplicate)</span>

                <span class="k">if</span> <span class="n">function</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># This is a scalar, no need to add it among the functions</span>

                <span class="k">pass</span>

        <span class="c1"># Make sure all functions have the same dimension, and store it so that the property .n_dim of</span>
        <span class="c1"># the Function class will work</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">n_dim</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;CompositeFunction class can only handle 1-dimensional functions at the moment.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">function</span><span class="o">.</span><span class="n">n_dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">:</span>

                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s2">&quot;You cannot compose functions of different dimensionality&quot;</span><span class="p">)</span>

        <span class="c1"># Now assign a unique name to all the functions, to make clear which is which in the definition</span>
        <span class="c1"># and give an easy way for the user to understand which parameter belongs to which function</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_id_to_uid</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">expression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uuid_expression</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">):</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_id_to_uid</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">uuid</span>

            <span class="n">expression</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">function</span><span class="o">.</span><span class="n">uuid</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Save the expression</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expression</span> <span class="o">=</span> <span class="n">expression</span>

        <span class="c1"># Build the parameters dictionary assigning a new name to each parameter to account for possible</span>
        <span class="c1"># duplicates.</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_functions</span><span class="p">):</span>

            <span class="k">for</span> <span class="n">parameter_name</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="c1"># New name to avoid possible duplicates</span>

                <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s2">&quot;(.+)_[0-9]+$&quot;</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                    <span class="n">original_name</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">original_name</span> <span class="o">=</span> <span class="n">parameter_name</span>

                <span class="n">new_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">original_name</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

                <span class="c1"># Store the parameter under the new name (obviously this is a reference to the</span>
                <span class="c1"># parameter, not a copy, as always in python)</span>

                <span class="n">parameters</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameter</span>
                <span class="n">parameter</span><span class="o">.</span><span class="n">_change_name</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>

        <span class="c1"># Now build a meaningful description</span>

        <span class="n">_function_definition</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">expression</span><span class="p">,</span> <span class="s1">&#39;latex&#39;</span><span class="p">:</span> <span class="n">NO_LATEX_FORMULA</span><span class="p">}</span>

        <span class="n">Function</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;composite&#39;</span><span class="p">,</span> <span class="n">_function_definition</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_uuid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uuid_expression</span></div>

<div class="viewcode-block" id="CompositeFunction.set_units"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.CompositeFunction.set_units">[docs]</a>    <span class="k">def</span> <span class="nf">set_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_unit</span><span class="p">,</span> <span class="n">y_unit</span><span class="p">,</span> <span class="n">relaxed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">relaxed</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>

            <span class="c1"># This can happen when rebuilding a composite function during unpickling, when</span>
            <span class="c1"># there are more than two functions composed together. We do not need to to anything in that case</span>
            <span class="k">pass</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_requested_x_unit</span> <span class="o">=</span> <span class="n">x_unit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_requested_y_unit</span> <span class="o">=</span> <span class="n">y_unit</span>

            <span class="c1"># Just rely on the single functions to adjust themselves.</span>

            <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="s1">&#39;_make_dimensionless&#39;</span><span class="p">):</span>

                    <span class="n">function</span><span class="o">.</span><span class="n">set_units</span><span class="p">(</span><span class="n">x_unit</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="n">function</span><span class="o">.</span><span class="n">set_units</span><span class="p">(</span><span class="n">x_unit</span><span class="p">,</span> <span class="n">y_unit</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">expression</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expression</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_uuid_expression</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">name_1</span><span class="p">,</span> <span class="n">name_2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">name_2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">name_1</span><span class="o">.</span><span class="n">uuid</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">name_1</span><span class="p">,</span> <span class="s1">&#39;uuid&#39;</span><span class="p">):</span>

            <span class="n">name_1_uuid</span> <span class="o">=</span> <span class="n">name_1</span><span class="o">.</span><span class="n">uuid</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">name_1_uuid</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name_1</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">name_2</span><span class="p">,</span> <span class="s1">&#39;uuid&#39;</span><span class="p">):</span>

            <span class="n">name_2_uuid</span> <span class="o">=</span> <span class="n">name_2</span><span class="o">.</span><span class="n">uuid</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="n">name_2_uuid</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name_2</span>

        <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name_1_uuid</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">name_2_uuid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_decide_evaluate_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Assign to __call__ the right evaluate according to the type of the elements in the expression</span>

        <span class="n">operation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calling_sequence</span>

        <span class="n">np_operator</span> <span class="o">=</span> <span class="n">_operations</span><span class="p">[</span><span class="n">operation</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_np_operator</span> <span class="o">=</span> <span class="n">np_operator</span>

        <span class="k">if</span> <span class="n">np_operator</span> <span class="o">==</span> <span class="s2">&quot;compose&quot;</span><span class="p">:</span>

            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_f2</span><span class="p">,</span> <span class="s1">&#39;evaluate&#39;</span><span class="p">),</span> <span class="s2">&quot;Second member of .of cannot be a scalar&quot;</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f1</span><span class="o">.</span><span class="n">n_dim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f2</span><span class="o">.</span><span class="n">n_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Can only compose with .of functions of 1 variable&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span> <span class="o">=</span> <span class="n">_cf_evaluate_func_of_func</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Check whether the second member is a function, or a number</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f1</span><span class="p">,</span> <span class="s1">&#39;evaluate&#39;</span><span class="p">):</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f2</span><span class="p">,</span> <span class="s1">&#39;evaluate&#39;</span><span class="p">):</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span> <span class="o">=</span> <span class="n">_cf_evaluate_func_func</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span> <span class="o">=</span> <span class="n">_cf_evaluate_func_number</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f2</span><span class="p">,</span> <span class="s1">&#39;evaluate&#39;</span><span class="p">):</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span> <span class="o">=</span> <span class="n">_cf_evaluate_number_func</span>

                <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>

                    <span class="c1"># Should never get here!</span>

                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Should never get here&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;A list containing the function used to build this composite function&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_functions</span>

<div class="viewcode-block" id="CompositeFunction.evaluate"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.CompositeFunction.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;You cannot instance and use a composite function by itself. Use the factories.&quot;</span><span class="p">)</span></div>

    <span class="c1"># This dumb function must be here because it is not possible to override at runtime __call__ (nor any other</span>
    <span class="c1"># special method)</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_np_operator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f2</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># For composite function, fast_call is the same as __call__ (because the call will be forwarded to the</span>
    <span class="c1"># inner functions)</span>

    <span class="n">fast_call</span> <span class="o">=</span> <span class="fm">__call__</span>

    <span class="c1"># Override the to_dict method of the Node class to add the expression to re-build this</span>
    <span class="c1"># composite function</span>
<div class="viewcode-block" id="CompositeFunction.to_dict"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.CompositeFunction.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimal</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="n">data</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">CompositeFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">minimal</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">minimal</span><span class="p">:</span>

            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;expression&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expression</span>

        <span class="k">return</span> <span class="n">data</span></div></div>


<div class="viewcode-block" id="get_function"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.get_function">[docs]</a><span class="k">def</span> <span class="nf">get_function</span><span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="n">composite_function_expression</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the function &quot;name&quot;, which must be among the known functions or a composite function.</span>

<span class="sd">    :param function_name: the name of the function (use &#39;composite&#39; if the function is a composite function)</span>
<span class="sd">    :param composite_function_expression: composite function specification such as</span>
<span class="sd">    ((((powerlaw{1} + (sin{2} * 3)) + (sin{2} * 25)) - (powerlaw{1} * 16)) + (sin{2} ** 3.0))</span>
<span class="sd">    :return: the an instance of the requested class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check whether this is a composite function or a simple function</span>
    <span class="k">if</span> <span class="n">composite_function_expression</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># Composite function</span>

        <span class="k">return</span> <span class="n">_parse_function_expression</span><span class="p">(</span><span class="n">composite_function_expression</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">function_name</span> <span class="ow">in</span> <span class="n">_known_functions</span><span class="p">:</span>

            <span class="k">return</span> <span class="n">_known_functions</span><span class="p">[</span><span class="n">function_name</span><span class="p">]()</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Maybe this is a template</span>

            <span class="c1"># NOTE: import here to avoid circular import</span>

            <span class="kn">from</span> <span class="nn">astromodels.functions.template_model</span> <span class="kn">import</span> <span class="p">(</span><span class="n">MissingDataFile</span><span class="p">,</span>
                                                              <span class="n">TemplateModel</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>

                <span class="n">instance</span> <span class="o">=</span> <span class="n">TemplateModel</span><span class="p">(</span><span class="n">function_name</span><span class="p">)</span>

            <span class="k">except</span> <span class="n">MissingDataFile</span><span class="p">:</span>

                <span class="k">raise</span> <span class="n">UnknownFunction</span><span class="p">(</span><span class="s2">&quot;Function </span><span class="si">%s</span><span class="s2"> is not known. Known functions are: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                      <span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_known_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">return</span> <span class="n">instance</span></div>


<div class="viewcode-block" id="get_function_class"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.get_function_class">[docs]</a><span class="k">def</span> <span class="nf">get_function_class</span><span class="p">(</span><span class="n">function_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the type for the requested function</span>

<span class="sd">    :param function_name: the function to return</span>
<span class="sd">    :return: the type for that function (i.e., this is a class, not an instance)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">function_name</span> <span class="ow">in</span> <span class="n">_known_functions</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">_known_functions</span><span class="p">[</span><span class="n">function_name</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">raise</span> <span class="n">UnknownFunction</span><span class="p">(</span><span class="s2">&quot;Function </span><span class="si">%s</span><span class="s2"> is not known. Known functions are: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                              <span class="p">(</span><span class="n">function_name</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_known_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">()))))</span></div>


<div class="viewcode-block" id="list_functions"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function.list_functions">[docs]</a><span class="k">def</span> <span class="nf">list_functions</span><span class="p">():</span>

    <span class="c1"># Gather all defined functions and their descriptions</span>

    <span class="n">functions_and_descriptions</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Description&#39;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">_function_definition</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]}</span>
                                  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">_known_functions</span><span class="o">.</span><span class="n">items</span><span class="p">())}</span>

    <span class="c1"># Order by key (i.e., by function name)</span>

    <span class="n">ordered</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">(</span>
        <span class="nb">sorted</span><span class="p">(</span><span class="n">functions_and_descriptions</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

    <span class="c1"># Format in a table</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">dict_to_table</span><span class="p">(</span><span class="n">ordered</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">table</span></div>


<div class="viewcode-block" id="_parse_function_expression"><a class="viewcode-back" href="../../../notebooks/api/astromodels.functions.html#astromodels.functions.function._parse_function_expression">[docs]</a><span class="k">def</span> <span class="nf">_parse_function_expression</span><span class="p">(</span><span class="n">function_specification</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse a complex function expression like:</span>

<span class="sd">    ((((powerlaw{1} + (sin{2} * 3)) + (sin{2} * 25)) - (powerlaw{1} * 16)) + (sin{2} ** 3.0))</span>

<span class="sd">    and return a composite function instance</span>

<span class="sd">    :param function_specification:</span>
<span class="sd">    :return: a composite function instance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># NOTE FOR SECURITY</span>
    <span class="c1"># This function has some security concerns. Security issues could arise if the user tries to read a model</span>
    <span class="c1"># file which has been maliciously formatted to contain harmful code. In this function we close all the doors</span>
    <span class="c1"># to a similar attack, except for those attacks which assume that the user has full access to a python environment.</span>
    <span class="c1"># Indeed, if that is the case, then the user can already do harm to the system, and so there is no point in</span>
    <span class="c1"># safeguard that from here. For example, the user could format a subclass of the Function class which perform</span>
    <span class="c1"># malicious operations in the constructor, add that to the dictionary of known functions, and then interpret</span>
    <span class="c1"># it with this code. However, if the user can instance malicious classes, then why would he use astromodels to</span>
    <span class="c1"># carry out the attack? Instead, what we explicitly check is the content of the function_specification string,</span>
    <span class="c1"># so that it cannot by itself do any harm (by for example containing instructions such as os.remove).</span>

    <span class="c1"># This can be a arbitrarily complex specification, like</span>
    <span class="c1"># ((((powerlaw{1} + (sin{2} * 3)) + (sin{2} * 25)) - (powerlaw{1} * 16)) + (sin{2} ** 3.0))</span>

    <span class="c1"># Use regular expressions to extract the set of functions like function_name{number},</span>
    <span class="c1"># then build the set of unique functions by using the constructor set()</span>

    <span class="n">unique_functions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span>
        <span class="sa">r</span><span class="s1">&#39;\b([a-zA-Z0-9_]+)\{([0-9]?)\}&#39;</span><span class="p">,</span> <span class="n">function_specification</span><span class="p">))</span>

    <span class="c1"># NB: unique functions is a set like:</span>
    <span class="c1"># {(&#39;powerlaw&#39;, &#39;1&#39;), (&#39;sin&#39;, &#39;2&#39;)}</span>

    <span class="c1"># Create instances of the unique functions</span>

    <span class="n">instances</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Loop over the unique functions and create instances</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">unique_function</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span> <span class="ow">in</span> <span class="n">unique_functions</span><span class="p">:</span>

        <span class="n">complete_function_specification</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">{</span><span class="si">%s</span><span class="s2">}&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">unique_function</span><span class="p">,</span> <span class="n">number</span><span class="p">)</span>

        <span class="c1"># As first safety measure, check that the unique function is in the dictionary of _known_functions.</span>
        <span class="c1"># This could still be easily hacked, so it won&#39;t be the only check</span>

        <span class="k">if</span> <span class="n">unique_function</span> <span class="ow">in</span> <span class="n">_known_functions</span><span class="p">:</span>

            <span class="c1"># Get the function class and check that it is indeed a proper Function class</span>

            <span class="n">function_class</span> <span class="o">=</span> <span class="n">_known_functions</span><span class="p">[</span><span class="n">unique_function</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">function_class</span><span class="p">,</span> <span class="n">Function</span><span class="p">):</span>

                <span class="c1"># Ok, let&#39;s create the instance</span>

                <span class="n">instance</span> <span class="o">=</span> <span class="n">function_class</span><span class="p">()</span>

                <span class="c1"># Append the instance to the list</span>

                <span class="n">instances</span><span class="p">[</span><span class="n">complete_function_specification</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">raise</span> <span class="n">FunctionDefinitionError</span><span class="p">(</span><span class="s2">&quot;The function specification </span><span class="si">%s</span><span class="s2"> does not contain a proper function&quot;</span>
                                              <span class="o">%</span> <span class="n">unique_function</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># It might be a template</span>

            <span class="c1"># This import is here to avoid circular dependency between this module and TemplateModel.py</span>
            <span class="kn">import</span> <span class="nn">astromodels.functions.template_model</span>

            <span class="k">try</span><span class="p">:</span>

                <span class="n">instance</span> <span class="o">=</span> <span class="n">astromodels</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">TemplateModel</span><span class="p">(</span>
                    <span class="n">unique_function</span><span class="p">)</span>

            <span class="k">except</span> <span class="n">astromodels</span><span class="o">.</span><span class="n">functions</span><span class="o">.</span><span class="n">template_model</span><span class="o">.</span><span class="n">MissingDataFile</span><span class="p">:</span>

                <span class="c1"># It&#39;s not a template</span>

                <span class="k">raise</span> <span class="n">UnknownFunction</span><span class="p">(</span><span class="s2">&quot;Function </span><span class="si">%s</span><span class="s2"> in expression </span><span class="si">%s</span><span class="s2"> is unknown. If this is a template model, you are &quot;</span>
                                      <span class="s2">&quot;probably missing the data file&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">unique_function</span><span class="p">,</span> <span class="n">function_specification</span><span class="p">))</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># It&#39;s a template</span>

                <span class="n">instances</span><span class="p">[</span><span class="n">complete_function_specification</span><span class="p">]</span> <span class="o">=</span> <span class="n">instance</span>

    <span class="c1"># Check that we have found at least one instance.</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instances</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">raise</span> <span class="n">DesignViolation</span><span class="p">(</span><span class="s2">&quot;No known function in function specification&quot;</span><span class="p">)</span>

    <span class="c1"># The following presents a slight security problem if the model file that has been parsed comes from an untrusted</span>
    <span class="c1"># source. Indeed, the use of eval could make possible to execute things like os.remove.</span>
    <span class="c1"># In order to avoid this, first we substitute the function instances with numbers and remove the operators like</span>
    <span class="c1"># +,-,/ and so on. Then we try to execute the string with ast.literal_eval, which according to its documentation:</span>

    <span class="c1"># Safely evaluate an expression node or a Unicode or Latin-1 encoded string containing a Python literal or</span>
    <span class="c1"># container display. The string or node provided may only consist of the following Python literal structures:</span>
    <span class="c1"># strings, numbers, tuples, lists, dicts, booleans, and None.This can be used for safely evaluating strings</span>
    <span class="c1"># containing Python values from untrusted sources without the need to parse the values oneself.</span>
    <span class="c1"># It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.</span>

    <span class="c1"># If literal_eval cannot parse the string, it means that it contains unsafe input.</span>

    <span class="c1"># Create a copy of the function_specification</span>

    <span class="n">string_for_literal_eval</span> <span class="o">=</span> <span class="n">function_specification</span>

    <span class="c1"># Remove from the function_specification all the known operators and function_expressions, and substitute them</span>
    <span class="c1"># with a 0 and a space</span>

    <span class="c1"># Let&#39;s start from the function expression</span>

    <span class="k">for</span> <span class="n">function_expression</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>

        <span class="n">string_for_literal_eval</span> <span class="o">=</span> <span class="n">string_for_literal_eval</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">function_expression</span><span class="p">,</span> <span class="s1">&#39;0 &#39;</span><span class="p">)</span>

    <span class="c1"># Now remove all the known operators</span>

    <span class="k">for</span> <span class="n">operator</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">_operations</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>

        <span class="n">string_for_literal_eval</span> <span class="o">=</span> <span class="n">string_for_literal_eval</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">operator</span><span class="p">,</span> <span class="s1">&#39;0 &#39;</span><span class="p">)</span>

    <span class="c1"># The string at this point should contains only numbers and parenthesis separated by one or more spaces</span>

    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;([a-zA-Z]+)&#39;&#39;&#39;</span><span class="p">,</span> <span class="n">string_for_literal_eval</span><span class="p">):</span>

        <span class="k">raise</span> <span class="n">DesignViolation</span><span class="p">(</span><span class="s2">&quot;Extraneous input in function specification&quot;</span><span class="p">)</span>

    <span class="c1"># By using split() we separate all the numbers and parenthesis in a list, then we join them</span>
    <span class="c1"># with a comma, to end up with a comma-separated list of parenthesis and numbers like:</span>
    <span class="c1"># ((((0,0,(0,0,3)),0,(0,0,25)),0,(0,0,16)),0,(0,0,0,3.0))</span>
    <span class="c1"># This string can be parsed by literal_eval as a tuple containing other tuples, which is fine.</span>
    <span class="c1"># If the user has inserted some malicious content, like os.remove or more weird stuff like code objects,</span>
    <span class="c1"># the parsing will fail</span>

    <span class="n">string_for_literal_eval</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">string_for_literal_eval</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

    <span class="c1"># print(string_for_literal_eval)</span>

    <span class="c1"># At this point the string should be just a comma separated list of numbers</span>

    <span class="c1"># Now try to execute the string</span>
    <span class="k">try</span><span class="p">:</span>

        <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">string_for_literal_eval</span><span class="p">)</span>

    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">SyntaxError</span><span class="p">):</span>

        <span class="k">raise</span> <span class="n">DesignViolation</span><span class="p">(</span>
            <span class="s2">&quot;The given expression is not a valid function expression&quot;</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># The expression is safe, let&#39;s eval it</span>

        <span class="c1"># First substitute the reference to the functions (like &#39;powerlaw{1}&#39;) with a string</span>
        <span class="c1"># corresponding to the instance dictionary</span>

        <span class="n">sanitized_function_specification</span> <span class="o">=</span> <span class="n">function_specification</span>

        <span class="k">for</span> <span class="n">function_expression</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">instances</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>

            <span class="n">sanitized_function_specification</span> <span class="o">=</span> <span class="n">sanitized_function_specification</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">function_expression</span><span class="p">,</span>
                                                                                        <span class="s1">&#39;instances[&quot;</span><span class="si">%s</span><span class="s1">&quot;]&#39;</span> <span class="o">%</span>
                                                                                        <span class="n">function_expression</span><span class="p">)</span>

        <span class="c1"># Now eval it. For safety measure, I remove all globals, and the only local is the &#39;instances&#39; dictionary</span>

        <span class="n">composite_function</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">sanitized_function_specification</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{</span>
                                  <span class="s1">&#39;instances&#39;</span><span class="p">:</span> <span class="n">instances</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">composite_function</span></div>
</pre></div>

           </div>
           
          </div>

          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2016--2021, G.Vianello, J. M. Burgess, N. Di Lalla, N. Omodei, H. Fleischhack.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>